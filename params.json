{"name":"Hilaris Application","body":"### Einleitung\r\nDie nachfolgende Beschreibung zur Installation wurde auf einem 64 \\& 32bit Ubuntu 12.04 LTS getestet.\r\n\r\n#### Konfiguration der Kamera\r\nUm die Kamera zu konfigurieren, beziehungsweise Anwendungen zu starten, bietet die leanXcam eine Ethernet-Schnittstelle über welche kommuniziert werden kann. Die IP-Adresse der Kamera ist standardmässig\tauf 192.168.1.10 eingestellt. Per SSH kann mit dem Befehl ```ssh root@192.168.1.10``` und dem Passwort \"oscar\" eine  Verbindung hergestellt werden.  Sollte dies nicht der Fall sein und die IP-Adresse muss zurück gesetzt werden, kann die Kamera ohne Netzwerkkabel an den Strom angeschlossen werden, womit die Adresse temporär zurückgesetzt wird.  Nun kann die Kamera an das Netzwerk angeschlossen um die IP-Adresse neu zu setzen. Dies geschieht wiederum über eine SSH Verbindung und dem Befehl  ```fw_setenv ipaddr <IP Adresse>```. Die IP Adresse muss auch gesetzt werden, wenn sie gleich wie die temporäre Adresse ist. Alternativ zu einer IP Adresse kann auch \"dhcp\" angegeben  werden, damit die Kamera eine dynamische Adresse bezieht. \r\nWeitere Informationen zur Benutzung und Konfiguration der Kamera können unter dem Link http://leanxcam.origo.ethz.ch/wiki/users_guideusing_uclinux gefunden werden.\r\n\r\n#### Entwicklungsumgebung\r\nUm Anwendungen für die Kamera kompilieren zu können, wird die _bfin-uclinux_-Toolchain benötigt.\r\nDiese steht in einer virtuellen Maschine zur Verfügung, welche von der Firma SCS AG als Torrent-Download (http://download.origo.ethz.ch/leanxcam/2089/leanXcam_SDK_v3.0.torrent) bereitgestellt\twird.\r\nMöchte man nicht in einer virtuellen Umgebung arbeiten, muss diese Toolchain zuerst installiert werden.\tDazu müssen folgende Befehle der Reihe nach im Terminal ausgeführt werden.\r\n\r\n```\r\n$> sudo apt-get install g++-multilib\r\n\r\n$> wget http://download.analog.com/27516/distros/debian/apt.key\r\n$> sudo apt-key add apt.key\r\n\r\n$> sudo su -\r\n#> mkdir -p /etc/apt/sources.list.d\r\n#> cd /etc/apt/sources.list.d\r\n#> echo deb http://download.analog.com/27516/distros/debian stable main > blackfin.sources.list\r\n\r\n#> apt-get update\r\n#> apt-get install blackfin-toolchain-uclinux blackfin-toolchain-linux-uclibc\r\n\r\n#> exit\r\n\r\n$> echo export PATH=$PATH:/opt/uClinux/bfin-uclinux/bin:/opt/uClinux/bfin-linux-uclibc/bin >> ~/.bashrc\r\n\r\n$> bash\r\n```\r\n\r\nNun werden noch die Hilaris-Bibliotheken und eine Vorlage benötigt, welche unter http://hilaris.github.com/app gefunden werden können. Nach dem Entpacken des Archivs, welche  als Vorlage für eine Anwendung dient, kann mit Entwickeln der ersten Anwendung begonnen werden.  Das Hauptprogramm wie auch allfälliger weiterer Code befindet sich im Unterordner _sources_  wobei das Hauptprogramm mit _main.cpp_ benannt ist. Diese Datei soll später in den Beispielen  bearbeitet werden.\r\n\r\n#### Kompilieren & Ausführen\t\r\nZum Schluss muss die Anwendung noch kompiliert. Es gibt die Möglichkeit die Anwendung auf dem System zu testen, auf welchem sie entwickelt wurde (Host). Oder man führt sie direkt auf der Kamera (Target) aus. Mit dem Befehl _make_ werden die Quelldateien zu  einer Host- und einer Target-Anwendung kompiliert. Möchte man nur die Host- oder nur die Target-Anwendung erzeugen, kann dies mit _make host_ beziehungsweise _make target_ erreicht werden. \r\n* **Host - app_host** Die für den Host kompilierte Anwendung wird _app\\_host_ benannt und  befindet sich direkt im _app_ Verzeichnis. Ebenfalls darin liegt ein Testbild \t\tnamens _test.bmp_ welches als statisches Kamerabild verwendet wird, wenn die Anwendung auf dem\tHost ausgeführt wird. Dieses Testbild muss zwingend im selben Verzeichnis wie die Anwendung sein und der Name darf nicht geändert werden.\r\n* **Target - app_target** Die Target-Applikation muss nach dem kompilieren noch auf die Kamera geladen werden, was mithilfe des Befehls ```make deploy NAME=<App Name> IP=<IP Kamera>``` erreicht wird. Wenn kein Name oder keine IP-Adresse angegeben wird, wird _hilaris_ als Standardname sowie die Standard-IP-Adresse 192.168.1.10 verwendet. Danach muss mittels SSH auf die Kamera verbunden und die Applikation gestartet werden. Dazu befindet sich im Ordner _/mnt/app/<App Name>_ ein Skript _run.sh_ welches bereits gestartete Instanzen der Anwendung beendet und die neue startet. Soll eine Anwendung automatisch beim Start der Kamera ausgeführt werden, kann dies in der _runscript_ Umgebungsvariabel hinterlegt werden. Dafür muss wieder per SSH eine\tVerbindung mit der Kamera hergestellt und danach der Befehl ```fw_setenv runscript <Pfad zu run.sh>``` ausgeführt werden.\r\n\r\n\r\n##### Eclipse\r\nFalls Eclipse als Entwicklungsumgebung verwendet wird und das CDT Plugin installiert ist,  kann das _app_ Verzeichnis in ein Makefile-Projekt importiert werden. Dazu in Eclipse ein neues  Makefile-Projekt mit existierendem Sourcecode erzeugen und den Pfad zur app-Vorlage auswählen. Mit einem Rechtsklick auf das Projekt -> _Build Configurations_ -> _Build all_ können die Quelldateien kompiliert werden. Um die Host-Anwendung direkt in Eclipse auszuführen muss in der _Run Configuration_ die Datei _app_host_ als Anwendung ausgewählt werden. Zusätzlich bieten die optionalen Plugins _C/C++ Remote Launch_ und _Remote System Explorer_ die Möglichkeit die Target-Anwendung auf die Kamera  zu kopieren  und direkt aus Eclipse auszuführen. Dabei ist zu beachten, dass _Remote Launch_ kein kopieren via ```scp``` unterstüzt und somit FTP im passiven Modus verwendet werden muss. Sind  beide Plugins installiert kann für die Target-Anwendung eine zweite _Run Configuration_ konfiguriert werden. \r\n- - -\r\n**Hinweis** Falls Eclipse nicht über die Konsole gestartet wird, kann es vorkommen, dass die bfin-Toolchain nicht gefunden wird und die Fehlermeldung _/bin/sh: 1: bfin-uclinux-g++: not found_ erscheint. In diesem Fall muss Eclipse beendet und über die Konsole neu gestartet werden.\r\n- - -\r\n\r\n### Hello World\r\nAls Einstieg in die Entwicklung mit Hilaris dient wie so oft ein einfaches _Hello World_ Beispiel. Wie im nachfolgenden Listing ersichtlich, muss dazu als erstes die Header-Datei _Hilaris.h_ inkuldiert werden. Danach wird mit dem Erstellen des Hilaris-Objekts das Framework geladen und das Camera-Objekt erzeugt. Da beim Aufruf der Methode ```getCamera()``` keine Parameter gesetzt sind, werden für die Initialisierung der Kamera Standardeinstellungen, unter anderem der Standard-Debayer, verwendet. Durch Aufruf der Methode ```captureImage()``` wird ein Bild aufgenommen und ein Pointer auf das entsprechende Image-Objekt zurückgegeben.  Schlussendlich wird mittels eines Text-Objekts und der Methode ```drawObject()``` der Text _Hello World_ auf das Bild gezeichnet. Um das erzeugte Bild anschauen zu können, wird es zum Schluss als Bitmap auf dem Dateisystem abgelegt.\r\n\r\n```C++\r\n#include \"Hilaris.h\"\r\n\r\nint main(int argc, const char* argv[])\r\n{\r\n\tHilaris hilaris;\r\n\t\r\n\t//getting camera with standard properties\r\n\tCamera* camera = hilaris.getCamera();\r\n\t\r\n\tImage* image = camera->captureImage();\r\n\t\r\n\tText t(10, 10, 2, \"Hello World!\", 0xFFFFFF, 0x000000);\r\n\timage->drawObject(&t);\r\n\t\r\n\timage->save(\"helloworld.bmp\");\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n![Hello World Image](http://i.imgur.com/VjFcN.jpg)\r\n\r\n### Frameprozessoren\r\nUm die Verarbeitung eines Bildes sauber vom restliche Programmablauf zu trennen, gibt es in Hilaris \r\nsogenannte Frameprozessoren. Diese sind völlig unabhängig von der restlichen\r\nAnwendung und können gut für andere Anwendungen wiederverwertet werden.\r\n\r\nBevor ein Bild aufgenommen wird, müssen die gewünschten Frameprozessoren der Kamera mit \r\n```Camera::addFrameProcessor(FrameProcessor* processor)``` hinzugefügt werden. Sobald nun\r\ndie ```captureImage()```-Methode aufgerufen wird, wird das Bild automatisch vom Frameprozessor verarbeitet,\r\nbevor es zurückgegeben wird. Die selbst erstellten Frameprozessoren sind im Unterordner _processors_ \r\nabzulegen, weshalb die include-Direktive ```#include \"processors/<ProcessorName>.h\"``` lautet. \r\nIm folgenden Beispiel wird das Zeichnen des Texts aus dem Hauptprogramm in einen Frameprozessor ausgelagert.\r\n\r\n```C++\r\n#include \"Hilaris.h\"\r\n#include \"processors/HelloWorldProcessor.h\"\r\n\r\nint main(int argc, const char* argv[])\r\n{\r\n\tHilaris hilaris;\r\n\t\r\n\t//getting camera with standard properties\r\n\tCamera* camera = hilaris.getCamera();\r\n\t\r\n\tcamera->addFrameProcessor(new HelloWorldProcessor());\r\n\t\r\n\tImage* image = camera->captureImage();\r\n\t\r\n\timage->save(\"helloworld.bmp\");\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\nEin Frameprozessor muss die Klasse _FrameProcessor_ erweitern und die Methode ```process()``` überschreiben, \r\nhat aber sonst keinerlei Einschränkungen. Auch hier wird die include-Direktive \r\n```#include \"Hilaris.h\"``` benötigt, wie dies bei allen Klassen in Hilaris der Fall ist.\r\nFür den _HelloWorldProcessor_ sieht das wie im folgenden Listing aus. \r\n\r\n```C++\r\n#include \"Hilaris.h\"\r\n\r\nclass HelloWorldProcessor : public FrameProcessor\r\n{\r\n\tpublic:\r\n\t\tImage* process(Image* image);\t\r\n};\r\n```\r\n\r\nDas Verarbeiten des Bildes, beziehungsweise in diesem Beispiel das Zeichnen des Texts, geschieht nun in\r\nder Implementierung der ```process()```-Methode. Das nächste Listing zeigt, wie das im Beispiel des \r\nHelloWorldProcessors aussieht.\r\n\r\n```C++\r\n#include \"HelloWorldProcessor.h\"\r\n\r\nImage* HelloWorldProcessor::process(Image* image)\r\n{\r\n\tText t(10, 10, 2, \"Hello World!\", 0xFFFFFF, 0x000000);\r\n\t\r\n\timage->drawObject(&t);\r\n\t\r\n\treturn image;\r\n}\r\n```\r\n\r\n### StreamServer\r\nIn vielen Fällen kann es sehr interessant sein die Bilder, welche die Kamera verarbeitet, in einem Stream\r\nzu beobachten. Für diesen Zweck wurde der sogenannte _StreamServer_ entwickelt. Die Kamera kann wie bis\r\nanhin mit einem Debayer und verschiedenen Frameprozessoren ausgestattet werden. Anstatt jedoch die Bilder \r\nselbst in der main-Methode aufzunehmen, kann die Kamera dem StreamServer übergeben werden. Sobald dieser\r\ngestartet wird, beginnt er Bilder aufzunehmen, zu verarbeiten und danach an alle verbundenen Clients zu versenden.\r\nEin einfaches Beispiel könnte wie im folgenden Listing aussehen.\r\n\r\n```C++\r\n#include \"Hilaris.h\"\r\n#include \"processors/HelloWorldProcessor.h\"\r\n\r\nint main(int argc, const char* argv[])\r\n{\r\n\tHilaris hilaris;\r\n\t\r\n\t//getting camera with standard properties\r\n\tCamera* camera = hilaris.getCamera();\r\n\t\r\n\tcamera->addFrameProcessor(new HelloWorldProcessor());\r\n\t\r\n\tStreamServer s(camera);\r\n\ts.start();\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\nUm nun zu testen ob der StreamServer auch wirklich läuft, kann mit folgendem Befehl eine Verbindung\r\nzur Kamera hergestellt und der Stream angezeigt werden:\r\n\r\n```\r\nnc <IP-Kamera > 9003 | mplayer --demuxer rawvideo -rawvideo w=376:h=240:format=BGR24:fps=100 -vo x11\r\n```\r\n\r\n\r\n### Wichtige Funktionen\r\nIm folgenden Kapitel wird kurz auf die wichtigsten Funktionen diverser Klassen von Hilaris eingegangen.\r\nEine detailiere Beschreibung sämtlicher Funktionen kann der API-Referenz entnommen werden.\r\n\r\n#### Hilaris\r\n```C++\r\n// Camera mit Standardeinstellungen erzeugen \r\nCamera* Hilaris::getCamera();\r\n\r\n// Camera mit gewünschtem Debayer erzeugen \r\nCamera* Hilaris::getCamera(Debayer* debayer);\r\n\r\n// Camera mit selbst definierter Area of Interest erzeugen \r\nCamera* Hilaris::getCamera(\r\nuint16 lowX, \r\nuint16 lowY, \r\nuint16 width, \r\nuint16 height);\r\n\r\n// Camera mit selbst definierter Area of Interest,\r\n// gewünschtem Debayer, sowie Anzahl Buffer erzeugen\r\nCamera* Hilaris::getCamera(\r\nuint16 lowX, \r\nuint16 lowY, \r\nuint16 width, \r\nuint16 height, \r\nDebayer* debayer, \r\nuint8 bufferSize);\r\n\r\n// Zurücksetzen des Camera Objekts um ein Neues zu erzeugen\r\nvoid Hilaris::resetCamera();\r\n\r\n// Einstellung des Log-Levels, welcher auf der Konsole ausgegeben wird\r\nvoid Hilaris::setConsoleLogLevel(const enum Debug::Level level);\r\n\r\n// Einstellung des Log-Levels, welcher in die Log-Datei geschrieben wird\r\nvoid Hilaris::setFileLogLevel(const enum Debug::Level level);\r\n\r\n// Zugriff auf die Instanz des IO Objekts\r\nIO* Hilaris::io();\r\n```\r\n\t\r\n#### Camera\r\n```C++\r\n// Bild aufnehmen und mit zuvor definiertem Debayer verarbeiten\r\nImage* Camera::captureImage();\r\n\r\n// Automatische Belichtungszeit ein- oder ausschalten\r\nbool Camera::setAutoExposure(bool enabled);\r\n\r\n// Belichtungszeit in Mikrosekunden einstellen\r\nbool Camera::setShutterWidth(uint32 width);\r\n\r\n// Ausrichtung des Bildes einstellen\r\nbool Camera::setPerspective(enum Camera::Perspective perspective);\r\n\r\n// FrameProcessor hinzufügen, welcher bei captureImage() aufgerufen wird\r\nbool Camera::addFrameProcessor(FrameProcessor* proc);\r\n```\t\r\n\r\n#### Image\r\n```C++\r\n// Bild als Bitmap speichern\r\nvoid Image::save(const char* path);\r\n\r\n// Objekte eines Overlays auf das Bild zeichnen\r\nvoid Image::drawOverlay(Overlay* overlay);\r\n\r\n// Einzelnes Objekt auf das Bild zeichnen\r\nvoid Image::drawObject(DrawableObject* object);\r\n\r\n// Breite eines Bildes erhalten\r\nuint16 Image::getWidth();\r\n\r\n// Höhe eines Bildes erhalten\r\nuint16 Image::getHeight();\r\n\r\n// Maximale Breite eines Bildes\r\nint Image::MAX_WIDTH;\r\n\r\n// Maximale Höhe eines Bildes\r\nint Image::MAX_HEIGHT;\r\n```\r\n\r\n```C++\r\n// Auslesen oder setzen eines Pixels\r\nuint8& GreyscaleImage::pixel(uint16 x, uint16 y);\r\nuint8& GreyscaleImage::operator()(uint16 x, uint16 y);\r\n\r\n// Konvertierung von GreyscaleImage nach BinaryImage\r\nBinaryImage* GreyscaleImage::convert(\r\nBinaryImage* binary, \r\nuint8 threshold = 127, \r\nbool darkIsForeground = false);\r\n\r\n// Filerkernel (GAUSS3X3, GAUSS5X5, MEDIAN3X3, MEDIAN5X5) auf Bild anwenden\r\nbool GreyscaleImage::filter(struct OSC_VIS_FILTER_KERNEL *kernel);\r\n\r\n// Kantendetektion auf einem Graustufenbild\r\nbool GreyscaleImage::sobel(uint8 exp = 10);\r\n```\r\n\r\n```C++\r\n// Binärbild invertieren\r\nvoid BinaryImage::invert();\r\n\r\n// Zwei Binärbilder voneinander subtrahieren\r\nvoid BinaryImage::subtract(BinaryImage* img);\r\n\r\n// Erosion auf einem Binärbild mit Strukturelement (DISK0, DISK1, DISK2, DISK8)\r\nbool BinaryImage::erode(struct OSC_VIS_STREL *strel, uint8 repetitions = 1);\r\n\r\n// Dilatation auf einem Binärbild mit Strukturelement\r\nbool BinaryImage::dilate(struct OSC_VIS_STREL *strel, uint8 repetitions = 1);\r\n\r\n// Finden und kennzeichnen der einzelnen Segmente in einem Binärbild\r\nbool BinaryImage::label();\r\n\r\n// Schwerpunkt aller Segmente im Bild markieren\r\nbool BinaryImage::drawCentroid();\r\n\r\n// Box um jedes der Segmente zeichnen\r\nbool BinaryImage::drawBoundingBox();\r\n```\r\n\r\n#### IO\r\n```C++\r\n// Gewünschter Pin (IN1, IN2, OUT1, OUT2) aktivieren oder deaktivieren\r\nbool IO::write(enum IO::Pin pin, bool active);\r\n\r\n// Von gewünschtem Pin lesen\r\nbool IO::read(enum IO::Pin pin);\r\n\r\n// Zugriff auf LED-Instanz\r\nLed* IO::led();\r\n\r\n// LED einschalten\r\nbool Led::on();\r\n\r\n// LED mit bestimmter Farbe einschalten\r\nbool Led::on(uint8 red, uint8 green);\r\n\r\n// Farbe des LED setzen\r\nbool Led::setColor(uint8 red, uint8 green);\r\n\r\n// LED ausschalten\r\nbool Led::off();\r\n```\r\n\r\n#### Debayer\r\nDie Debayer-Klassen stellen keine Funktionalität zur Verfügung, welche direkt verwendet \r\nwerden kann. Folgend jedoch eine Liste der wichtigsten Debayer mit ihren Eigenschaften.\r\n\r\n* **DebayerBGRFast**: Erzeugt ein _BGRImage_ mit halber Breite sowie halber Höhe. Dieser Debayer wird standardmässig verwendet, wenn kein Debayer spezifiziert wurde.\r\n* **DebayerBGRHalfsize**: Erzeugt ein _BGRImage_ mit halber Breite sowie halber Höhe.\r\n* **DebayerBGRBilinear**: Erzeugt ein _BGRImage_ mit voller Grösse.\r\n* **DebayerBGRStandard**: Erzeugt ein _BGRImage_ mit voller Grösse.\r\n* **DebayerGreyscaleFast**: Erzeugt ein _GreyscaleImage_ mit halber Breite sowie halber Höhe.\r\n* **DebayerGreyscaleHalfsize**: Erzeugt ein _GreyscaleImage_ mit halber Breite und Höhe.\r\n* **DebayerGreyscaleVector**: Erzeugt ein _GreyscaleImage_ mit halber Breite und halber Höhe.\r\n* **DebayerRGBStandard**: Erzeugt ein _RGBImage_ mit halber Breite und Höhe.\r\n* **DebayerRaw**: Erzeugt ein undverarbeitets _RawImage_ welches nur aus Rohdaten besteht.","tagline":"sources which are used to develop applications for the leanXcam with the Hilaris framework","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}